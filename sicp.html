<?xml version="1.0" encoding="utf-8"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN"
"http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="en" xml:lang="en">
<head>
<!-- 2026-01-19 Mon 23:30 -->
<meta http-equiv="Content-Type" content="text/html;charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1" />
<title>Let's Do Structure and Interpretation of Computer Programs (SICP)</title>
<meta name="author" content="jbh" />
<meta name="generator" content="Org Mode" />
<style type="text/css">
  #content { max-width: 60em; margin: auto; }
  .title  { text-align: center;
             margin-bottom: .2em; }
  .subtitle { text-align: center;
              font-size: medium;
              font-weight: bold;
              margin-top:0; }
  .todo   { font-family: monospace; color: red; }
  .done   { font-family: monospace; color: green; }
  .priority { font-family: monospace; color: orange; }
  .tag    { background-color: #eee; font-family: monospace;
            padding: 2px; font-size: 80%; font-weight: normal; }
  .timestamp { color: #bebebe; }
  .timestamp-kwd { color: #5f9ea0; }
  .org-right  { margin-left: auto; margin-right: 0px;  text-align: right; }
  .org-left   { margin-left: 0px;  margin-right: auto; text-align: left; }
  .org-center { margin-left: auto; margin-right: auto; text-align: center; }
  .underline { text-decoration: underline; }
  #postamble p, #preamble p { font-size: 90%; margin: .2em; }
  p.verse { margin-left: 3%; }
  pre {
    border: 1px solid #e6e6e6;
    border-radius: 3px;
    background-color: #f2f2f2;
    padding: 8pt;
    font-family: monospace;
    overflow: auto;
    margin: 1.2em;
  }
  pre.src {
    position: relative;
    overflow: auto;
  }
  pre.src:before {
    display: none;
    position: absolute;
    top: -8px;
    right: 12px;
    padding: 3px;
    color: #555;
    background-color: #f2f2f299;
  }
  pre.src:hover:before { display: inline; margin-top: 14px;}
  /* Languages per Org manual */
  pre.src-asymptote:before { content: 'Asymptote'; }
  pre.src-awk:before { content: 'Awk'; }
  pre.src-authinfo::before { content: 'Authinfo'; }
  pre.src-C:before { content: 'C'; }
  /* pre.src-C++ doesn't work in CSS */
  pre.src-clojure:before { content: 'Clojure'; }
  pre.src-css:before { content: 'CSS'; }
  pre.src-D:before { content: 'D'; }
  pre.src-ditaa:before { content: 'ditaa'; }
  pre.src-dot:before { content: 'Graphviz'; }
  pre.src-calc:before { content: 'Emacs Calc'; }
  pre.src-emacs-lisp:before { content: 'Emacs Lisp'; }
  pre.src-fortran:before { content: 'Fortran'; }
  pre.src-gnuplot:before { content: 'gnuplot'; }
  pre.src-haskell:before { content: 'Haskell'; }
  pre.src-hledger:before { content: 'hledger'; }
  pre.src-java:before { content: 'Java'; }
  pre.src-js:before { content: 'Javascript'; }
  pre.src-latex:before { content: 'LaTeX'; }
  pre.src-ledger:before { content: 'Ledger'; }
  pre.src-lisp:before { content: 'Lisp'; }
  pre.src-lilypond:before { content: 'Lilypond'; }
  pre.src-lua:before { content: 'Lua'; }
  pre.src-matlab:before { content: 'MATLAB'; }
  pre.src-mscgen:before { content: 'Mscgen'; }
  pre.src-ocaml:before { content: 'Objective Caml'; }
  pre.src-octave:before { content: 'Octave'; }
  pre.src-org:before { content: 'Org mode'; }
  pre.src-oz:before { content: 'OZ'; }
  pre.src-plantuml:before { content: 'Plantuml'; }
  pre.src-processing:before { content: 'Processing.js'; }
  pre.src-python:before { content: 'Python'; }
  pre.src-R:before { content: 'R'; }
  pre.src-ruby:before { content: 'Ruby'; }
  pre.src-sass:before { content: 'Sass'; }
  pre.src-scheme:before { content: 'Scheme'; }
  pre.src-screen:before { content: 'Gnu Screen'; }
  pre.src-sed:before { content: 'Sed'; }
  pre.src-sh:before { content: 'shell'; }
  pre.src-sql:before { content: 'SQL'; }
  pre.src-sqlite:before { content: 'SQLite'; }
  /* additional languages in org.el's org-babel-load-languages alist */
  pre.src-forth:before { content: 'Forth'; }
  pre.src-io:before { content: 'IO'; }
  pre.src-J:before { content: 'J'; }
  pre.src-makefile:before { content: 'Makefile'; }
  pre.src-maxima:before { content: 'Maxima'; }
  pre.src-perl:before { content: 'Perl'; }
  pre.src-picolisp:before { content: 'Pico Lisp'; }
  pre.src-scala:before { content: 'Scala'; }
  pre.src-shell:before { content: 'Shell Script'; }
  pre.src-ebnf2ps:before { content: 'ebfn2ps'; }
  /* additional language identifiers per "defun org-babel-execute"
       in ob-*.el */
  pre.src-cpp:before  { content: 'C++'; }
  pre.src-abc:before  { content: 'ABC'; }
  pre.src-coq:before  { content: 'Coq'; }
  pre.src-groovy:before  { content: 'Groovy'; }
  /* additional language identifiers from org-babel-shell-names in
     ob-shell.el: ob-shell is the only babel language using a lambda to put
     the execution function name together. */
  pre.src-bash:before  { content: 'bash'; }
  pre.src-csh:before  { content: 'csh'; }
  pre.src-ash:before  { content: 'ash'; }
  pre.src-dash:before  { content: 'dash'; }
  pre.src-ksh:before  { content: 'ksh'; }
  pre.src-mksh:before  { content: 'mksh'; }
  pre.src-posh:before  { content: 'posh'; }
  /* Additional Emacs modes also supported by the LaTeX listings package */
  pre.src-ada:before { content: 'Ada'; }
  pre.src-asm:before { content: 'Assembler'; }
  pre.src-caml:before { content: 'Caml'; }
  pre.src-delphi:before { content: 'Delphi'; }
  pre.src-html:before { content: 'HTML'; }
  pre.src-idl:before { content: 'IDL'; }
  pre.src-mercury:before { content: 'Mercury'; }
  pre.src-metapost:before { content: 'MetaPost'; }
  pre.src-modula-2:before { content: 'Modula-2'; }
  pre.src-pascal:before { content: 'Pascal'; }
  pre.src-ps:before { content: 'PostScript'; }
  pre.src-prolog:before { content: 'Prolog'; }
  pre.src-simula:before { content: 'Simula'; }
  pre.src-tcl:before { content: 'tcl'; }
  pre.src-tex:before { content: 'TeX'; }
  pre.src-plain-tex:before { content: 'Plain TeX'; }
  pre.src-verilog:before { content: 'Verilog'; }
  pre.src-vhdl:before { content: 'VHDL'; }
  pre.src-xml:before { content: 'XML'; }
  pre.src-nxml:before { content: 'XML'; }
  /* add a generic configuration mode; LaTeX export needs an additional
     (add-to-list 'org-latex-listings-langs '(conf " ")) in .emacs */
  pre.src-conf:before { content: 'Configuration File'; }

  table { border-collapse:collapse; }
  caption.t-above { caption-side: top; }
  caption.t-bottom { caption-side: bottom; }
  td, th { vertical-align:top;  }
  th.org-right  { text-align: center;  }
  th.org-left   { text-align: center;   }
  th.org-center { text-align: center; }
  td.org-right  { text-align: right;  }
  td.org-left   { text-align: left;   }
  td.org-center { text-align: center; }
  dt { font-weight: bold; }
  .footpara { display: inline; }
  .footdef  { margin-bottom: 1em; }
  .figure { padding: 1em; }
  .figure p { text-align: center; }
  .equation-container {
    display: table;
    text-align: center;
    width: 100%;
  }
  .equation {
    vertical-align: middle;
  }
  .equation-label {
    display: table-cell;
    text-align: right;
    vertical-align: middle;
  }
  .inlinetask {
    padding: 10px;
    border: 2px solid gray;
    margin: 10px;
    background: #ffffcc;
  }
  #org-div-home-and-up
   { text-align: right; font-size: 70%; white-space: nowrap; }
  textarea { overflow-x: auto; }
  .linenr { font-size: smaller }
  .code-highlighted { background-color: #ffff00; }
  .org-info-js_info-navigation { border-style: none; }
  #org-info-js_console-label
    { font-size: 10px; font-weight: bold; white-space: nowrap; }
  .org-info-js_search-highlight
    { background-color: #ffff00; color: #000000; font-weight: bold; }
  .org-svg { }
</style>
<style> body {max-width: 62.5rem; padding: 1rem; margin: auto; background-color: #fafad2} </style>
<script>
  window.MathJax = {
    tex: {
      ams: {
        multlineWidth: '85%'
      },
      tags: 'ams',
      tagSide: 'right',
      tagIndent: '.8em'
    },
    chtml: {
      scale: 1.0,
      displayAlign: 'center',
      displayIndent: '0em'
    },
    svg: {
      scale: 1.0,
      displayAlign: 'center',
      displayIndent: '0em'
    },
    output: {
      font: 'mathjax-modern',
      displayOverflow: 'overflow'
    }
  };
</script>

<script
  id="MathJax-script"
  async
  src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js">
</script>
</head>
<body>
<div id="content" class="content">
<h1 class="title">Let's Do Structure and Interpretation of Computer Programs (SICP)</h1>
<div id="table-of-contents" role="doc-toc">
<h2>Table of Contents</h2>
<div id="text-table-of-contents" role="doc-toc">
<ul>
<li><a href="#org6e75880">SICP (and SDF)</a>
<ul>
<li><a href="#orgdce5322">SICP in 2026</a></li>
<li><a href="#org9228de4">Optional lectures</a></li>
</ul>
</li>
<li><a href="#org644d1b8">SETUP</a>
<ul>
<li><a href="#orgdaeeff6">Book versions</a></li>
<li><a href="#orgae63a8b">Install mit-scheme</a></li>
<li><a href="#org805fde9">IDE/Editor</a></li>
</ul>
</li>
<li><a href="#orge641df0">BEGIN</a>
<ul>
<li><a href="#orgcceda47">SICP 1.x</a></li>
<li><a href="#org10cc593">SICP 1.2.1</a></li>
<li><a href="#org1af5db6">SICP 1.2.2</a></li>
<li><a href="#org7af5e8e">SICP 1.2.3</a></li>
<li><a href="#org4426a18">SICP 1.2.4</a></li>
<li><a href="#org5faeb6a">SICP 1.2.5</a></li>
<li><a href="#org9558c45">SICP 1.2.6</a></li>
<li><a href="#org6d9f7f4">SICP 1.3.1</a></li>
</ul>
</li>
<li><a href="#orgc3cec6a">SDF 0</a></li>
</ul>
</div>
</div>
<div id="outline-container-org6e75880" class="outline-2">
<h2 id="org6e75880">SICP (and SDF)</h2>
<div class="outline-text-2" id="text-org6e75880">
<p>
This exists because if you ask around how to learn programming likely someone will shill this book to you due to it being a seminal CS text that's been used for decades and is now even more relevant in the Gemini/ChatGPT and Claude Code AI world of development tools as we will learn all about procedural abstraction something that AI is still very poor at doing.
</p>

<p>
It's easier to do this after you have at least some programming experience because then you won't miss as many details as SICP gives you everything at once. Most readers like myself will get hung up on the first few chapters because of the math examples thus give up immediately but they are only examples and not the core of the text so don't give up so easily. In interviews the authors explained this course was taught at MIT after 2 or 3 semesters of calculus so for that target audience it made sense to use math examples. 
</p>

<p>
SICP is lecture notes that became a book the original 6.001 course had many additional assignments to the book exercises. Some examples of these are <a href="https://ocw.mit.edu/courses/6-001-structure-and-interpretation-of-computer-programs-spring-2005/pages/projects/">here</a> and <a href="https://mitp-content-server.mit.edu/books/content/sectbyfn/books_pres_0/6515/sicp.zip/psets/index.html">here</a>. Instead of doing those old 6.001 assignments I'm going to do the 2025 <a href="https://groups.csail.mit.edu/mac/users/gjs/6.945/assignments.html">assignments</a> from Sussman's 6.945 <a href="https://groups.csail.mit.edu/mac/users/gjs/6.945/index.html">course</a> and new book <i>Software Design for Flexibility</i> (SDF) where many of those assignments point to chapters in SICP.
</p>

<p>
SDF teaches the exact opposite of current day software engineering showing how in nature complex systems are designed for flexibility so new abilities can be effortlessly added without needing to do any kind of rewriting of the existing system. This is exactly what you would want if using some AI to generate code. 
</p>
</div>
<div id="outline-container-orgdce5322" class="outline-3">
<h3 id="orgdce5322">SICP in 2026</h3>
<div class="outline-text-3" id="text-orgdce5322">
<p>
This is still the best book for learning the abstract art of programming. MIT taught some form of this book in their 6.001 course from 1980 until 2007 and I think still offers <a href="https://web.mit.edu/6.001/6.037/">a condensed version</a> in 6.037 (now 6.9550). UC Berkeley teaches a <a href="https://cs61a.org/">Python</a> derivative of the book and there is an authorized <a href="https://sourceacademy.org/sicpjs">JavaScript</a> 2022 version taught at the National University of Singapore but the authors have had to make significant <a href="https://sicp.sourceacademy.org/chapters/prefaces03.html">changes</a> in chapter 4 because of the limitations of JavaScript.
</p>
</div>
</div>
<div id="outline-container-org9228de4" class="outline-3">
<h3 id="org9228de4">Optional lectures</h3>
<div class="outline-text-3" id="text-org9228de4">
<p>
There is lectures from 1986 <a href="https://www.youtube.com/playlist?list=PLE18841CABEA24090">here</a> and if you search YouTube many more recent lectures from Berkeley and countless hackathons or compsci reading groups have videos on working through the book. 
</p>
</div>
</div>
</div>
<div id="outline-container-org644d1b8" class="outline-2">
<h2 id="org644d1b8">SETUP</h2>
<div class="outline-text-2" id="text-org644d1b8">
</div>
<div id="outline-container-orgdaeeff6" class="outline-3">
<h3 id="orgdaeeff6">Book versions</h3>
<div class="outline-text-3" id="text-orgdaeeff6">
<p>
I'm using the official <a href="https://mitp-content-server.mit.edu/books/content/sectbyfn/books_pres_0/6515/sicp.zip/index.html">online version</a> and one of unofficial <a href="https://web.mit.edu/6.001/6.037/sicp.pdf">PDFs</a> floating around to see the figures which can sometimes be impossible to read in the online html version. There's also an <a href="https://www.neilvandyke.org/sicp-texi/%20">info version</a> you can run in the terminal or in another emacs window. Remember those are unofficial so there could be extra errata introduced.
</p>
</div>
</div>
<div id="outline-container-orgae63a8b" class="outline-3">
<h3 id="orgae63a8b">Install mit-scheme</h3>
<div class="outline-text-3" id="text-orgae63a8b">
<p>
To do the book read the <a href="https://groups.csail.mit.edu/mac/users/gjs/6.945/dont-panic/">setup instructions</a> from Sussman's grad course and only use <a href="https://www.gnu.org/software/mit-scheme/">mit-scheme</a> or you may have problems in later chapters when we need to use the picture language or <a href="https://mitp-content-server.mit.edu/books/content/sectbyfn/books_pres_0/6515/sicp.zip/psets/ps7/readme.html">parallel.scm</a> or mutable lists. Guile scheme may work for the entire book too but I have no idea, it has a <a href="https://elephly.net/guile-picture-language/manual.html">picture language</a> at least.
</p>

<p>
If you have an M-series chip Mac then <a href="https://mac.getutm.app/">UTM app</a> will effortlessly run ARM64 Ubuntu/Debian/Arch VMs that work with mit-scheme. Homebrew can be used to <a href="https://formulae.brew.sh/cask/utm">install</a> the free version. These VMs don't even need a GUI installed you can do everything from the edwin editor in the terminal. You could even rent a <a href="https://lowendbox.com/">low end box</a> for $20/year and ssh directly into it and run edwin.
</p>

<p>
I'm aware of #lang sicp in DrRacket and many other 3rd party implementations you can start with those for the first few chapters but if you want to do Sussman's more recent books like SCM or SDF you're going to have to use the latest mit-scheme anyway so we may as well begin with using the language the book actually wants us to use.   
</p>
</div>
</div>
<div id="outline-container-org805fde9" class="outline-3">
<h3 id="org805fde9">IDE/Editor</h3>
<div class="outline-text-3" id="text-org805fde9">
<p>
You can type code into any text editor, save as filename.scm, run mit-scheme, and load your file in the REPL (load "filename.scm") but an IDE with scheme mode to help balance parens and run interactive debugging will be much easier. 
</p>

<p>
For the purposes of SICP and SDF we only need edwin so that's what I'll use here. Edwin is a clone of an old emacs version (Emacs 18 see the ref card below) and edwin is entirely written in mit-scheme so as you complete this book you can hack your own editor to do anything you want.  
</p>

<p>
You start edwin with <i>mit-scheme - -edit</i> and are good to go without needing to install anything else as a scheme shell spawns immediately upon opening and debugging is all built-in.
</p>

<ul class="org-ul">
<li>Editor <a href="https://groups.csail.mit.edu/mac/users/gjs/6.945/dont-panic/#org6d580b9">setup</a> from 6.945 and <a href="http://groups.csail.mit.edu/mac/users/gjs/6946/">setup</a> from 6.946 for emacs or edwin</li>
<li>Sussman's .edwin config file <a href="http://web.mit.edu/6.945/dont-panic/.edwin">here</a> for better fonts (save in home directory as .edwin (with the period))</li>
<li>Edwin specific docs <a href="https://www.gnu.org/software/mit-scheme/documentation/stable/mit-scheme-user/Edwin.html">here</a> (it has a stepper too) 
<ul class="org-ul">
<li>Edwin <a href="http://groups.csail.mit.edu/mac/users/gjs/6946/cheat-sheet.pdf">ref card</a></li>
<li>MIT lab <a href="http://groups.csail.mit.edu/mac/projects/scheme/documentation/nwwyw_4.html#SEC32">doc</a> on Edwin commands and how to use the debugger</li>
</ul></li>
</ul>

<p>
If you use emacs I wouldn't recommend installing <a href="https://paredit.org/screencast/fib-fact.gif">Paredit mode</a> or Geiser or anything until you start writing larger programs in the later chapters because you learn scope in the beginning by seeing how all the parens close blocks of expressions and having something automatically shifting around parens when you don't have experience is going to be rage inducing. When your programs start becoming one big function in chapter 4 then install tools.    
</p>

<p>
Commands:
</p>
<ul class="org-ul">
<li>C-x C-c (exit emacs/edwin) is hold down Ctrl and type x, keep holding Ctrl and type c.</li>
<li>C-h t is hold down Ctrl and type h, release Ctrl and type t (starts the tutorial). 
<ul class="org-ul">
<li>PgUp/PgDn, End/Home, arrow keys and mouse all work too you don't have to use the movement commands in tutorial though eventually you will see how fast you become if you do decide to learn them.</li>
</ul></li>
<li>M-x the M is the 'meta' key which on a modern keyboard is usually ALT (sometimes the Windows key) but you can redefine both C and M to be something else.</li>
<li>C-g or Ctrl-g is the escape key if you accidentally screw up mid command and want to try again.</li>
</ul>
</div>
</div>
</div>
<div id="outline-container-orge641df0" class="outline-2">
<h2 id="orge641df0">BEGIN</h2>
<div class="outline-text-2" id="text-orge641df0">
<p>
Assuming you downloaded Sussman's <a href="http://web.mit.edu/6.945/dont-panic/.edwin">edwin config</a> and saved it as ".edwin" in your home directory or even whatever directory you're running mit-scheme type the following:
</p>

<ul class="org-ul">
<li>mit-scheme - -edit</li>
</ul>

<p>
You should get a 1980s green text screen that presents you with a single window (the scheme REPL). You can already program in this buffer try entering (+ 1 1) and C-x C-e to get ;Value: 2. Read the edwin <a href="https://www.gnu.org/software/mit-scheme/documentation/stable/mit-scheme-user.html#Edwin">documentation</a> for mit-scheme.
</p>

<p>
Next:
</p>

<ul class="org-ul">
<li>C-x C-f and type test.scm</li>
</ul>

<p>
A new blank editor buffer will open. Now let's get a split-screen, if you want your new window to the right instead of below type C-x 3
</p>

<ul class="org-ul">
<li>C-x 2</li>
<li>C-x o (lower case o)
<ul class="org-ul">
<li>or just click on the bottom window</li>
</ul></li>
<li>C-x b and press enter to open default scheme buffer</li>
<li>C-x o to return to editor window</li>
</ul>

<p>
Now you have a screen to enter code with and a REPL below. In emacs there is no default scheme REPL buffer (unless you configure one) you have to manually run M-x mit-scheme to start it. 
</p>

<p>
<b>Eval code</b>
</p>

<p>
In test.scm editor buffer enter some random code:
</p>
<pre class="example" id="org8397d63">
(define x 3)
(+ x 2)
(+ x 2 2)
"this is a string"
;this is a comment
</pre>

<p>
Run it in the REPL with M-o (eval entire buffer) or type C-h m to get a list of available key bindings/commands to evaluate scheme expressions. To switch out of the help buffer type C-x b and the default will be test.scm or wherever you were last. You can control which code you want to run and often the Lisp developer procedure is to eval a single function and then manually input tests for it in the REPL.
</p>

<p>
C-x C-s saves your editing window buffer and C-x C-c will <a href="https://www.gnu.org/software/mit-scheme/documentation/stable/mit-scheme-user.html#Leaving-Edwin">leave</a> edwin/scheme. 
</p>

<p>
<b>Errors</b>
</p>

<p>
If you get something similar:
</p>
<pre class="example" id="org353cf63">
;Unbound variable: *2
;To continue, call RESTART with an option number:
; (RESTART 3) =&gt; Specify a value to use instead of *2.
; (RESTART 2) =&gt; Define *2 to a given value.
; (RESTART 1) =&gt; Return to read-eval-print level 1.
</pre>
<p>
Then typing (restart 1) will return to the REPL and you can check your code again to fix the problem or you can try one of the options to fix the problem. The bulk of errors will be parens problems in the beginning but it's how you learn and after a few of them you're much more careful about code and what scope it's in. If you run the debugger type C-h m to get a list of commands. Read the <a href="https://groups.csail.mit.edu/mac/users/gjs/6.945/dont-panic/">don't panic</a> guide how to debug.
</p>
</div>
<div id="outline-container-orgcf7d047" class="outline-4">
<h4 id="orgcf7d047">Edwin demo in Lecture 1</h4>
<div class="outline-text-4" id="text-orgcf7d047">
<p>
First <a href="https://www.youtube.com/watch?v=-J_xL4IGhJA">lecture</a> from the 1986 series if you want to follow him with edwin like @35:40 in the video:
</p>

<ul class="org-ul">
<li>Start edwin with 'mit-scheme &#x2013;edit'</li>
<li>C-x 2 (split screen like he has)</li>
<li>C-x C-f and type in lecture.scm (it will create this file)</li>
<li>Any expressions eval with C-x C-e 
<ul class="org-ul">
<li>Press tab to indent when he demos 'pretty printing'</li>
</ul></li>
</ul>
</div>
</div>
<div id="outline-container-orgd8eef33" class="outline-4">
<h4 id="orgd8eef33">Run the tutorial!</h4>
<div class="outline-text-4" id="text-orgd8eef33">
<p>
Hold Ctrl-h then type t to start the tutorial so you understand what 'point' means (the location of the current cursor) and all the cut + paste commands.
</p>
</div>
</div>
<div id="outline-container-orgcceda47" class="outline-3">
<h3 id="orgcceda47">SICP 1.x</h3>
<div class="outline-text-3" id="text-orgcceda47">
<p>
I would not read these early chapters very fast as it builds up showing the various abstractions in incremental levels that will be needed for later chapters.
</p>

<p>
A computational process I would interpret as a running program or the act of computation itself. A procedure is sometimes called a function in modern programming parlance but the book makes it clear later in this chapter these are different things pointing out how a math function definition is nothing like a procedure.
</p>

<p>
Write yourself some notes. These chapters tell us everything is an expression and every expression has a value. Procedures themselves are a value. A sequence of expressions within parens is a combination where the operator is applied to the values of the expressions. The operator can be a simple procedure or a compound very complex procedure. These complex procedures can be named so we can refer to their results. The environment (scope) is the range of significance that a name has where some names are globally accessible and others only locally within procedures. 
</p>

<p>
This is what they mean by the evaluation rule is recursive
</p>
<ul class="org-ul">
<li>(+ 1 (+ 2 (* 3 4)))</li>
<li>(+ 1 (+ 2 (eval 3 4)))</li>
<li>(+ 1 (+ 2 12))</li>
<li>(+ 1 (eval 2 12))</li>
<li>(+ 1 14)
<ul class="org-ul">
<li>15</li>
</ul></li>
</ul>

<p>
In order to evaluate an expression it has to evaluate the most nested subexpression the rule points to itself like a loop that keeps evaluating until recursion stops and a value is produced. Special forms are not procedures because they aren't always evaluated and if the OR procedure returns true for one expression in a chain of OR's then it doesn't need to evaluate anymore expressions.
</p>


<p>
Ex 1.2 is an example of an impossible to read figure. Use the <a href="http://libgen.is/book/index.php?md5=2E2D076C195F245EED60A5D3B00BE993">pdf</a>.
</p>
<pre class="example" id="org66c1a7b">
(/ (+ 5 4 (- 2 (- 3 (+ 6 (/ 4 5)))))
   (* 3 (- 6 2) (- 2 7)))
</pre>

<p>
Ex 1.3 simple (cond (and ())) you can write your own test cases/examples too:
</p>
<pre class="example" id="org1ae8082">
(= (three-square-sum 1 2 3) (+ (* 2 2) (* 3 3))
(= (three-square-sum 3 1 2) 13)
(= (three-square-sum 3 2 1) 13)
(= (three-square-sum 1 1 1) 2)
(= (three-square-sum 0 1 0) 1)
</pre>

<p>
Ex 1.4 many languages won't let you do this and is a good example of symbolic programming it evals to (+ a b) if b &gt; 0 or (- a b) if not.  
</p>

<p>
Ex 1.5 (define (p) (p)) is a non-terminating loop where (p) keeps calling itself. Since normal-order doesn't eval arguments into values until they are needed (p) is never run because it's never needed as (test 0 (p)) will always evaluate to 0. Under applicative-order however it evaluates all the arguments first so will evaluate (p) and go into an infinite loop. 
</p>

<p>
Ex 1.6 new-if is a regular procedure not a special form so it's input (all the subexpressions) are evaluated first with applicative-order eval. The three inputs to new-if: (good-enough? guess x) returns a boolean, guess is already a value, but (sqrt-iter (improve guess x) x) will keep improving the guess until the end of days as the cond predicate good-enough? is never reached to stop the recursion. The special-form if/else does not automatically evaluate the else clause it preforms the predicate test first.
</p>

<p>
Ex 1.7 try examples: 
</p>

<pre class="example" id="orga82164a">
1 ]=&gt; (sqrt 0.0009)
;Value: .04030062264654547

1 ]=&gt; (sqrt 1000000000000000)
;takes forever, infinite loop?
</pre>

<p>
Subtracting the square of the guess from the radicand isn't precise enough for small numbers and very large numbers clearly they never meet that precision or it takes too long to do so. If we ratio the change in guess with the existing guess, the closer the guess is the closer the ratio approaches 1 so we can adjust our program to check for this by subtracting that ratio from 1 to see if the two guesses are within epsilon (0.001) of each other.
</p>

<pre class="example" id="orgf5902bf">
(define (good-enough? guess x)
  (&lt; (abs(- 1 (/ (improve guess x) guess))) 0.001))
</pre>

<p>
Now gigantic square roots eval immediately and tiny square roots are close enough to wolfram alpha online calculator precision. 
</p>

<p>
Ex. 1.8 The cube root of 8 is 2 or 2 * 2 * 2. Plugging that into the formula: (8/4 + 4)/3 or 6/3 = 2. All I did was change improve procedure and delete average procedure since it wasn't needed anymore:
</p>

<pre class="example" id="orgdeff9d9">
(define (improve guess x)
  (/ (+ (/ x (* guess guess)) (* 2 guess)) 3))
</pre>

<p>
1.1.8 <i>Black-Box Abstractions</i> if you look at the mit-scheme <a href="https://www.gnu.org/software/mit-scheme/documentation/stable/mit-scheme-ref.html#index-exp">documentation</a> and scroll to the index at the bottom you'll find definitions for exp and log which are e<sup>x</sup> and ln(x). We can see this ourselves using <a href="https://www.desmos.com/calculator/gren2g4hrs">desmos</a>. Graph both ln(x) and exp(x) then go along the x-axis to 2, go up until it meets the blue ln(x) line, it lands at y = 0.7 or so. Double 0.7 to get 1.4 then travel along the x-axis to 1.4, go up to the orange exp(x) line and you'll see it intersect at y = 4 or exp(log(2) + log(2)) is 4. Both e and ln ('the natural log') are preferred for math modeling because it has properties like the derivative of e is itself, this square property we just learned, and that you can estimate e<sup>x</sup> and ln(x) simply on a piece of paper when working with small displacements. For example e<sup>x</sup> for small x like 0.05 is <a href="https://youtu.be/flge97Jp6uo">1 + x</a> and ln(1 + x) is x.      
</p>
</div>
</div>
<div id="outline-container-org10cc593" class="outline-3">
<h3 id="org10cc593">SICP 1.2.1</h3>
<div class="outline-text-3" id="text-org10cc593">
<p>
I rewrote fact-iter to instead be a function nested inside another function, with a 'trampoline' meaning execution falls to the bottom of the function hitting (f 1 n) and bounces back calling f(). A factorial is a product of every number up to the nth factorial so 3! is 1x2x3. 
</p>

<pre class="example" id="org752429e">
(define (factorial n)
  (define (f total counter)
    (if (&lt; counter 2)
	total
	(f (* total counter) (- counter 1))))
  (f 1 n))

(factorial 6)
(factorial 1)
(factorial 0)
</pre>

<p>
The difference in the book between the delayed chain of operations and the iterated version is called re-entry. The delayed chain has to re-enter the same function before returning a value so must keep all that accounting of state somewhere which we will eventually learn is a stack frame. 
</p>

<p>
Ex 1.9 addition is defined as a function that uses <i>a</i> as a counter and increments <i>b</i> everytime there is still an <i>a</i> left until <i>a</i> = 0. The first function (inc (function call)) is going to return a chain of increments until <i>a</i> = 0 then all delayed increment operations will be done. 
</p>
</div>
<div id="outline-container-org8f7eb77" class="outline-4">
<h4 id="org8f7eb77">Ex 1.10</h4>
<div class="outline-text-4" id="text-org8f7eb77">
<p>
I assume 'concise math definitions' means turn (* 5 n n) into 5n<sup>2</sup> and if you plug in some values to f then f(n) = 2y. If you are using edwin you can run the stepper see the <a href="https://www.gnu.org/software/mit-scheme/documentation/stable/mit-scheme-user.pdf">manual</a> for mit-scheme. Otherwise hand step:
</p>

<pre class="example" id="org673c60c">
(define (A x y)
  (cond ((= y 0) 0)
        ((= x 0) (* 2 y))
        ((= y 1) 2)
        (else (A (- x 1)
                 (A x (- y 1))))))

(define (g n) (A 1 n))
(define (h n) (A 2 n))

(g 2)
- (A 1 2)
- (A 0 (A 1 1))
- (A 0 (2)) 
- (* 2 2)
- 4

(h 3)
- (A 2 3)
- (A 1 (A 2 2)))
- (A 1 (A 1 (A 2 1)))
- (A 1 (A 1 2))
- (A 1 (A 0 (A 1 1)))
- (A 1 (A 0 (2)))
- (A 1 (* 2 2))
- (A 1 4)
- (A 0 (A 1 3))
- (A 0 (A 0 (A 1 2)))
- (A 0 (A 0 (A 0 (A 0 1))))
- (A 0 (A 0 (A 0 (2))))
- (A 0 (A 0 (4)))
- (A 0 (* 2 4))
- (A 0 (8))
- (* 2 8)
- 16
</pre>

<p>
G seems to produce 2<sup>n</sup> while H generates sequence 2, 4, 16, 65536&#x2026; or \(2^{2^2..}\). 
</p>
</div>
</div>
</div>
<div id="outline-container-org1af5db6" class="outline-3">
<h3 id="org1af5db6">SICP 1.2.2</h3>
<div class="outline-text-3" id="text-org1af5db6">
<p>
Phi or \(\varphi\) is a constant like e and there's many articles and videos on <a href="https://www.goldennumber.net/math/">Phi</a>. In case it wasn't clear in the book the iterative algorithm comes from the observation that 0, 1, 1, 2, 3, 5.. the next in the sequence is the sum of the previous 2 numbers.   
</p>

<p>
Hand step the count-change procedure with only 2 coins and amount 1: 
</p>

<ul class="org-ul">
<li>(+ (cc 1 2 (+ (cc 1 1) (cc 1 0))))</li>
<li>(+ (cc 1 2 (+ (cc 1 1) 0)))</li>
<li>(+ (cc 1 2 (+ (cc (1 - 1) 0))))</li>
<li>(+ (cc 1 2 (+ 1 0)))</li>
<li>(+ (cc (1 - 2) 1))</li>
<li>(+ 0 1)</li>
<li>1</li>
</ul>

<p>
The computations are delayed as (+) needs two arguments so recursion is unrolled fully then evaluation can begin once it stops with 0 or 1. 
</p>
</div>
<div id="outline-container-orgefd22b0" class="outline-4">
<h4 id="orgefd22b0">Ex 1.11</h4>
<div class="outline-text-4" id="text-orgefd22b0">
<p>
Write examples 1, 2, 4, 11, 25, 59.. enter it into <a href="https://oeis.org/A100550">OEIS</a> and there's actually a generating function solution a physicist figured out however the assignment wants us to create an iterable procedure. You can use the slower recursive procedure we learned to test your iterative one. I took eqv? from the mit-scheme reference manual.
</p>

<pre class="example" id="org18e48e3">
(define (f n)
  (define (f-iter n1 n2 n3 counter)
    (cond ((&lt; n 3) n)
	  ((= counter n) n1)
	  (else
	   (f-iter (+ n1 (* 2 n2) (* 3 n3)) n1 n2 (+ counter 1)))))
  (f-iter 2 1 0 2))
  
(define (g n)
  (cond ((&lt; n 3 ) n )
	(else (+
	       (g (- n 1))
	       (* 2 (g (- n 2)))
	       (* 3 (g (- n 3)))))))
(and
 (eqv? (f 1) (g 1))
 (eqv? (f 2) (g 2))
 (eqv? (f 3) (g 3))
 (eqv? (f 4) (g 4))
 (eqv? (f 0) (g 0)))
</pre>
</div>
</div>
<div id="outline-container-org9824f2c" class="outline-4">
<h4 id="org9824f2c">Ex 1.12</h4>
<div class="outline-text-4" id="text-org9824f2c">
<p>
Pascal's triangle or array is explained <a href="https://www.youtube.com/watch?v=h0Woqc_5qUE%20">here</a> as the number of paths you can take to get to that number in the array or the number of coefficients in (a + b)<sup>n</sup>
</p>

<pre class="example" id="org0c1b381">
(define (pascal row col)
  (cond ((= row 0) 1)
	((&gt; col row) 0)
        ((or (= col 0) (= col row)) 1)
        ((or (= col 1) (= col (- row 1))) row)  
        (else (+ (pascal (- row 1) (- col 1))
                 (pascal (- row 1) col)))))                                      
</pre>

<p>
For <a href="https://en.wikipedia.org/wiki/Pascal%27s_triangle#/media/File:Sierpinski_Pascal_triangle.svg">example</a> (pascal 4, 2) is 6. The first and last columns are always 1, the n+1 and n-1 columns are the same as the row number if you start counting from 0. The value of (pascal 4, 2) is the value of (+ (pascal 3, 1) (pascal 3 2)) which is (+ 3 (pascal 2 1) (pascal 2 2)) or (+ 3 2 1). Trying to get a middle column element from row 30 takes a long time as the recursive process is generating a tree branch on almost every remaining input. 
</p>

<p>
You can property test your program by noticing each element in a row of Pascal's array sums to \(2^{(row)}\): 
</p>

<pre class="example" id="org6deec1e">
(define (pascal row col)
  (cond ((= row 0) 1)
	((&gt; col row) 0)
        ((or (= col 0) (= col row)) 1)
        ((or (= col 1) (= col (- row 1))) row)  
        (else (+ (pascal (- row 1) (- col 1))
                 (pascal (- row 1) col)))))

(define (ptest n)
  (define (row-sum count)
    (cond ((= count 0) 1)
	  (else (+ (pascal n count) (row-sum (- count 1))))))
  (row-sum n))

(and
  (eqv? (ptest 2) (* 2 2))
  (eqv? (ptest 3) (* 2 2 2))
  (eqv? (ptest 10) (* 2 2 2 2 2 2 2 2 2 2)))
</pre>
</div>
</div>
<div id="outline-container-org72c3e11" class="outline-4">
<h4 id="org72c3e11">Ex 1.13</h4>
<div class="outline-text-4" id="text-org72c3e11">
<p>
Closest integer means a number like -1, 0, 1, 2, 3.. not a decimal/rational. Try some examples in scheme:
</p>

<pre class="example" id="org1292475">
(define (fib n)
  (cond ((= n 0) 0)
        ((= n 1) 1)
        (else (+ (fib (- n 1))
                 (fib (- n 2))))))

(define (phi x)
  (/ (x 1 (sqrt 5)) 2))

(define (f n)
  ;; expt and sqrt in mit-scheme reference doc
  (/ (- (expt (phi +) n) (expt (phi -) n)) (sqrt 5)))

(fib 11)
(f 11)
(fib 12)
(f 12)
</pre>

<p>
Notation
</p>
<ul class="org-ul">
<li>\(\varphi\) is phi or (1 + sqrt(5))/2</li>
<li>\(\psi\) is psi or -1/phi or (1 - sqrt(5))/2</li>
</ul>

<p>
The book says to use the definition fib(n) = fib(n - 1) + fib(n - 2) and since fib(n) = \(\frac{\varphi^n - \psi^n}{\sqrt 5}\) we can substitute it wherever we see fib(n):
</p>

<p>
\[\frac{\varphi^n - \psi^n}{\sqrt 5} = \frac{\varphi^{n-1} - \psi^{n-1}}{\sqrt 5} + \frac{\varphi^{n-2} - \psi^{n-2}}{\sqrt 5}\]
</p>

<p>
Looking at this <a href="https://sicp-solutions.net/post/sicp-solution-exercise-1-13/">solution</a>: 
</p>

<ul class="org-ul">
<li>Clear the fractions by multiplying everything by \(\frac{\sqrt 5}{1}\) though \(\sqrt 5\) is itself \(2\varphi - 1\)</li>
</ul>

<p>
\[\varphi^n - \psi^n = \varphi^{n-1} - \psi^{n-1} + \varphi^{n-2} - \psi^{n-2}\]
</p>

<ul class="org-ul">
<li>Rewrite exponents to n. If n = 2 then 2<sup>2</sup> is 2*2 and (2*2)/2 is 2<sup>1</sup> or 2<sup>n-1</sup></li>
</ul>

<p>
\[\varphi^n-\psi^n=\frac{\varphi^n}\varphi-\frac{\psi^n}\psi+\frac{\varphi^n}{\varphi^2}-\frac{\psi^n}{\psi^2}\]
</p>

<ul class="org-ul">
<li>Group similar together and distribute out phi and psi numerators:</li>
</ul>

<p>
\[\varphi^n-\psi^n=\varphi^n\left(\frac1\varphi+\frac1{\varphi^2}\right)-\psi^n\left(\frac1\psi+\frac1{\psi^2}\right)\]
</p>

<p>
You could keep following their solution or take advantage of the fact that phi<sup>2</sup> = phi + 1, 1/phi = phi â€“ 1, 1/psi = 1/(-1/phi) or negative phi (\(-\varphi\)) to end up with \(\varphi^n - \psi^n = \varphi^n - \psi^n\) then use the same inequality reasoning they did to get to -1/2 &lt; phi/sqrt(5) &lt; 1/2  
</p>
</div>
</div>
</div>
<div id="outline-container-org7af5e8e" class="outline-3">
<h3 id="org7af5e8e">SICP 1.2.3</h3>
<div class="outline-text-3" id="text-org7af5e8e">
<p>
Watch the <a href="https://www.youtube.com/watch?v=V_7mmwpgJHU">lecture</a> @17:09 where he explains what time and space means though the whole lecture is worth watching. Time is the amount of steps that are evaluated and space is the amount of data needing to be stored. The numbers 16 and 8 differ by a constant factor of 2 and by a constant factor of 8 but as he says in this analysis we don't care what the constant is just that it is a constant and not changing with the input. Try the iterative procedure in the lecture that uses '1+' and '-1+' both built-in increment/decrement functions. 
</p>

<p>
He uses big-O in the lecture (and the book's first edition) and big-theta in the second edition we're reading. O(n) is an upper bound and \(\theta(n)\) is both a lower and an upper bound.
</p>

<p>
In the book the definition for \(\theta(f(n))\) is \(k_{1}f(n) \le R(n) \le k_{2}f(n)\)
</p>
<ul class="org-ul">
<li>the two k's represent constants we choose that can be the same or different</li>
<li>R(n) is a function we define that represents the resources for a process (space or steps) when given an input of size n</li>
<li>f(n) are the same functions and chosen from a list of existing math functions
<ul class="org-ul">
<li>f(n) = n (linear)</li>
<li>f(n) = n<sup>2</sup> (quadratic)</li>
<li>f(n) = log n (logarithmic)</li>
<li>f(n) = 1 (constant)</li>
<li>there actually is a specific list with more</li>
</ul></li>
</ul>

<p>
If R(n) = n100 meaning for every input 100 steps are processed, or n100 steps, then R(n) is within a constant factor of f(n) = n and fits the big-theta definition in the book cf(n) &lt;= n100 &lt;= kf(n) because both c and k can be chosen so that inequality holds. R(n) is in \(\theta(n)\) and belongs to the set of all functions f(n) = n or linear functions that perform at least linear work and at most linear work.
</p>

<p>
Big-O is an upper bound only. If R(n) is in O(n) then it is in the set of all functions bounded by the set of all linear functions. So far we are only looking at the computational process meaning the exact amount of steps generated and the storage needed to store the steps in memory. 
</p>

<p>
The \(\in\) symbol means 'is in' 
</p>

<ul class="org-ul">
<li>Fib(n) steps take R(n) = \(\frac{\varphi^n}{\sqrt 5}\) and we can choose the constants arbitrarily as the definition allows this so long as the inequality holds</li>
</ul>

<p>
\[\frac{1}{\sqrt 5}\cdot\varphi^n \le  \frac{\varphi^n}{\sqrt 5} \le 1\cdot\varphi^n \in \theta(\varphi^{n})\]  
</p>

<ul class="org-ul">
<li>The definition of big-O is \(R(n) \le kf(n)\) so any positive constant will work for fib(n) :</li>
</ul>

<p>
\[\frac{\varphi^n}{\sqrt 5} \le 1\cdot\varphi^n \in O(\varphi^{n})\]  
</p>

<ul class="org-ul">
<li>Phi is a constant 1.6180.. and (1.6)<sup>n</sup> &lt; 2<sup>n</sup> this is another upper bound though not as tight fitting but still fine according to the definition of big-O:</li>
</ul>

<p>
\[\frac{\varphi^n}{\sqrt 5} \le 1\cdot 2^n \in O(2^{n})\]  
</p>

<p>
Watch <a href="https://youtu.be/_gKb855_3bk?si=IOQF3DAvcbRfCHrB">this</a> to learn more like O-tilde, poly(), and what exactly are the standard form functions that are 'chosen from a list' in O(f(n)). That same lecture also explains why 'n' is used in O(f(n)) instead of O(f(x)) because in this analysis inputs are supposed to grow to infinity so n is used as a convention to represent near infinite inputs.
</p>

<p>
The formal definition of big-O and big-theta is that there exists some specific input n<sub>0</sub> where for every input n larger than n<sub>0</sub> the constants will always hold so you don't have to worry about tiny edge cases where inputs are small so long as the constant(s) hold eventually for all future inputs. 
</p>
</div>
<div id="outline-container-org20fac5f" class="outline-4">
<h4 id="org20fac5f">Ex 1.14</h4>
<div class="outline-text-4" id="text-org20fac5f">
<p>
There is a nice graphic <a href="https://sicp-solutions.net/post/sicp-solution-exercise-1-14/">here</a> showing the full (cc 11 5) tree. He used (display) to generate the data to plug into graphviz and we can do the same while adjusting the procedure to count the number of calls or nodes in the process tree. Zero out the cond then in the else add 2 for 2 calls to cc:
</p>

<pre class="example" id="org018e920">
(define (count-nodes amount)
  (cc amount 5))
(define (cc amount kinds-of-coins)
  (display "(cc ") (display amount) (display " ") (display kinds-of-coins) (display ")") (newline)
  (cond ((= amount 0) 0)
        ((or (&lt; amount 0) (= kinds-of-coins 0)) 0)
        (else (+ 2 ( + (cc amount (- kinds-of-coins 1))
                   (cc (- amount (first-denomination kinds-of-coins)) kinds-of-coins))))))
(define (first-denomination kinds-of-coins)
  (cond ((= kinds-of-coins 1) 1)
        ((= kinds-of-coins 2) 5)
        ((= kinds-of-coins 3) 10)
        ((= kinds-of-coins 4) 25)
        ((= kinds-of-coins 5) 50)))

1 ]=&gt; (count-nodes 1)
(cc 1 5)
(cc -49 5)
(cc 1 4)
(cc -24 4)
(cc 1 3)
(cc -9 3)
(cc 1 2)
(cc -4 2)
(cc 1 1)
(cc 0 1)
(cc 1 0)
;Value: 10
</pre>

<p>
We can do the same for the fib function and compare the result to the tree in the book (14 nodes not including the root) 
</p>

<pre class="example" id="org408e81a">
(define (fib-nodes n)
  (cond ((= n 0) 0)
        ((= n 1) 0)
        (else (+ 2 (fib-nodes (- n 1))
                 (fib-nodes (- n 2))))))

1 ]=&gt; (fib-nodes 5)
;Value: 14
</pre>

<p>
We can see count-change process steps are much less than fib:
</p>

<pre class="example" id="orge09f7a5">
1 ]=&gt; (fib-nodes 20)
;Value: 21890

1 ]=&gt; (fib-nodes 30)
;Value: 2692536

1 ]=&gt; (count-nodes 20)
;Value: 150

1 ]=&gt; (count-nodes 30)
;Value: 390
</pre>

<p>
Space is defined as the max depth of the longest tree branch because we only have to keep track of the nodes above us and count-change longest branch is whatever the input is since if there's a coin size of 1 it will take as a minimum n nodes of space of n-sized input so space's lowest bound is n. We can always find some constant to multiply n by in order to represent the rest of the space used in the tree for the other coin denominations meaning space is \(\theta(n)\) it won't exceed more than n(times a constant).
</p>

<p>
To estimate the amount of steps try gathering data and plot it:   
</p>

<p>
1 ]=&gt; (count-nodes 100)
;Value: 15498
</p>

<p>
1 ]=&gt; (count-nodes 200)
;Value: 229588
</p>

<p>
1 ]=&gt; (count-nodes 300)
;Value: 1292590
</p>

<p>
1 ]=&gt; (count-nodes 400)
;Value: 4642024
</p>

<p>
1 ]=&gt; (count-nodes 500)
;Value: 12822610
</p>

<p>
1 ]=&gt; (count-nodes 600)
;Value: 29806268
</p>

<p>
1 ]=&gt; (count-nodes 700)
;Value: 61312118
</p>

<p>
1 ]=&gt; (count-nodes 800)
;Value: 115126480
</p>

<p>
1 ]=&gt; (count-nodes 900)
;Value: 201422874
</p>

<p>
Plug it into a desmos like I did <a href="https://www.desmos.com/calculator/ywymhcs40z">here</a>. 
</p>

<p>
You can see for up to 900 inputs it's still bounded by x<sup>3</sup> but if you keep going then the points approach the y-axis quickly. As you add 100 to the input the nodes appear to roughly double in size as an upper bound so we can keep approximating and doubling the last value of nodes and see eventually the x<sup>3</sup> curve is no longer bounding. It will eventually pass x<sup>4</sup> too but it will always be bounded by x<sup>5</sup> and that is the critical insight to big-O or big-theta the inputs are supposed to be approaching infinity so no matter how big of an input you can guarantee the bound. 
</p>
</div>
</div>
<div id="outline-container-orgc0d817d" class="outline-4">
<h4 id="orgc0d817d">Ex 1.15</h4>
<div class="outline-text-4" id="text-orgc0d817d">
<p>
Build another step counter
</p>

<pre class="example" id="org04aa496">
(define (count c angle)
  (display c) (display " ") (display angle) (newline)
  (if (not (&gt; (abs angle) 0.1))
      c 
      (count (+ c 1) (/ angle 3.0))))
(count 0 12.5)

1 ]=&gt;
1 4.166666666666667
2 1.388888888888889
3 .462962962962963
4 .154320987654321
5 5.1440329218107005e-2
;Value: 5

(count 0 100)
1 ]=&gt; 
;Value: 7

(count 0 1000)
1 ]=&gt; 
;Value: 9
</pre>

<p>
The sine function calls (p (p (p (p (p 0.05144))))) and once the recursion stops and angle is returned then p can start to reduce. Try log<sub>2</sub>(100) and log<sub>2</sub>(1000) and see (sine a) is logarithmic in steps. We multiplied the steps by 10 and only added 2 more. Space is the bookkeeping we have to save and is the depth of p so also \(\theta\)(log(a)) as the assignment wants us to express it as a function of <i>a</i>.
</p>
</div>
</div>
</div>
<div id="outline-container-org4426a18" class="outline-3">
<h3 id="org4426a18">SICP 1.2.4</h3>
<div class="outline-text-3" id="text-org4426a18">
</div>
<div id="outline-container-org9a14ef9" class="outline-4">
<h4 id="org9a14ef9">Ex 1.16</h4>
<div class="outline-text-4" id="text-org9a14ef9">
<p>
The book states the invariant here is ab<sup>n</sup> meaning it's value should not change each time we iterate/loop (change state). The hint/observation is a(b<sup>2</sup>)<sup>n/2</sup> is always going to be ab<sup>n</sup> since 2n/2 is n and that is our even clause in the cond. The else clause or not even is bb<sup>n-1</sup> and abb<sup>n-1</sup> is of course ab<sup>n</sup> too. I wrote some tests here but this is Lisp at anytime you can manually enter tests into the REPL. 
</p>

<pre class="example" id="org49b6849">
(define (even? n)
  (= (remainder n 2) 0))

(define (square n)
  (* n n ))

(define (expt b n)
    (expt-iter 1 b n))

(define (expt-iter a b n)
  (cond ((= n 0) a)
	; a(b^2)^1/2
        ((even? n) (expt-iter a (square b) (/ n 2)))
	; abb^n-1
        (else (expt-iter (* a b) b (- n 1)))))

(define (test-expt)
  (and
   (eqv? (expt 0 1) 0)
   (eqv? (expt 1 0) 1)
   (eqv? (expt 1 2) (* 1 1))
   (eqv? (expt 2 3) (* 2 2 2))
   (eqv? (expt 3 7) (* 3 3 3 3 3 3 3))))
</pre>
</div>
</div>
<div id="outline-container-orga04c91c" class="outline-4">
<h4 id="orga04c91c">Ex 1.17</h4>
<div class="outline-text-4" id="text-orga04c91c">
<p>
Try examples, ab is b amount of times a is added to itself so 3 x 4 is 4 groups of 3 added or (+ 3 3 3 3) or 4 addition steps. How would double/half help us here? Applying the even test to b: (+ (double 3) (double 3)) is (+ 6 6) or 2 steps and lg(4) is 2. An odd example is 3 x 5 or (+ 3 (double 3) (double 3)) and that's our procedure. Whenever we can halve the product b we double a, if we can't we add whatever a is and reduce b by 1. 
</p>

<pre class="example" id="orgc095290">
(define (even? n)
  (= (remainder n 2) 0))

(define (double n)
  (+ n n ))

(define (halve n)
    (/ n 2))

(define (* a b)
  (cond ((= b 0) 0)
	((even? b) (* (double a) (halve b)))
	(else (+ a (* a (- b 1)))))))
</pre>

<p>
We can count the number of arithmetic steps by altering our procedure then check it against log (base e) a built-in procedure to make sure our number of steps are logarithmic. The book so far is only concerned with the actual steps for arithmetic they aren't concerned with what is the cost of calling halve and double so I assume those are constant step operations thus ignored:
</p>

<pre class="example" id="org3470c15">
(define (* a b)
  (cond ((= b 0) 0)
	((even? b) (* (double a) (halve b)))
	(else (+ 1 (* a (- b 1))))))

(display "Actual number of arithmetic steps:")
(* 2 100)
(* 2 1000)
(* 2 10000)
(display "log_e of 100, 1000, and 10000:")
(log 100)
(log 1000)
(log 10000)
</pre>
</div>
</div>
<div id="outline-container-org32c19ab" class="outline-4">
<h4 id="org32c19ab">Ex 1.19</h4>
<div class="outline-text-4" id="text-org32c19ab">
<p>
Apply the first state change a &lt;- bq + aq + ap and b &lt;- bp + aq
</p>

<ul class="org-ul">
<li>T<sub>pq</sub>(a, b)</li>
<li>= T<sub>pq</sub>(bq + aq + ap, bp + aq)</li>
</ul>

<p>
Then apply another state change (there is now 2 b's and 3 a's)
</p>

<ul class="org-ul">
<li>T<sub>p'q'</sub>(bq + aq + ap), bp + aq)</li>
<li>= T<sub>p'q'</sub>(bp + aq)q + (bq + aq + ap)q + (bq + aq + ap)p, (bp + aq)p + (bq + aq + ap)q</li>
</ul>

<p>
Distribute everything and group like terms
</p>

<ul class="org-ul">
<li>(bpq + bqq + bqp) + (aqq + aqq + aqp + aqp + app), (bpp + bqq) + (aqp + aqq + apq)</li>
</ul>

<p>
Factor out b and a
</p>

<ul class="org-ul">
<li>b(2pq + qq) + a(qq + qq + qp + qp + pp), b(qq + pp) + a(2pq + qq)</li>
<li>b(2pq + qq) + a(2pq + qq) + a(qq + pp), b(qq + pp) + a(2pq + qq)</li>
</ul>

<p>
q' is 2pq + q<sup>2</sup> and p' is q<sup>2</sup> + p<sup>2</sup> 
</p>

<p>
I only know this from <a href="https://learnaifromscratch.github.io/taocp.html">TAOCP</a> book with similar state changes otherwise iirc I didn't understand this exercise the first time I saw it years ago.
</p>
</div>
</div>
</div>
<div id="outline-container-org5faeb6a" class="outline-3">
<h3 id="org5faeb6a">SICP 1.2.5</h3>
<div class="outline-text-3" id="text-org5faeb6a">
<p>
This is 'integer division' or mod so the remainder 6 in GCD(206,40) is 200 with 6 remaining or 206 mod 40. 
</p>

<p>
The number of steps of GCD(206,40) is bounded by the log of the smaller of the two inputs or log(40) (base phi) and since n = 40 is the input this is \(\theta\)(log n). It is derived by taking the log of both sides of that inequality in the book.
</p>

<p>
You don't need to know this but if you were curious about Lame's theorem first we notice in each step of Euclid's algorithm it will have to find the gcd of two inputs that are smaller than the previous input. When you unroll the steps of the algorithm out like a recurrence (which we haven't yet learned) and you compare n, the second smaller input to each step, then the first step is n &gt;= 1 step, the second will be a sum of the last step which is n &gt;= 1 step, the third will be a sum of the last 2 steps which is n &gt;= 2 steps&#x2026; you see where this is going you eventually get the fib sequence: \(n \ge \frac{\varphi^k}{\sqrt 5}\) and take log of both sides log(n) \(\ge\) k * log(\(\varphi\)) + log(\(\sqrt 5\)) or log(n) \(\ge\) kc + c where c is some constant factors we don't care about. Now it's clear that the number of steps k are logarithmic in the size of the input n. Another way to tell this was logarithmic was to notice the input is tossed by half or more at each loop and in a log(input) number of steps we exhausted the input. 
</p>

<p>
This is something else I only know from reading <a href="https://learnaifromscratch.github.io/taocp.html">TAOCP</a> vol 2 section 4 which has a very long analysis of Euclid's algorithm.
</p>

<p>
Ex. 1.20 chapter 4 extensively covers this. Applicative-order all parameters are evaluated before being applied and normal-order is known as a form of 'lazy' eval where nothing is evaluated until needed. This results in a ton of normal-order remainder operations that I gave up counting after 8 whereas applicative-order is only 4 remainder ops. In a modern lazy eval language the problems of normal-order copying everything around are fixed by having parameters stored in a single location in memory so when they are applied as arguments to a procedure and copied only the value is copied as the parameter needs to be evaluated only once.     
</p>
</div>
</div>
<div id="outline-container-org9558c45" class="outline-3">
<h3 id="org9558c45">SICP 1.2.6</h3>
<div class="outline-text-3" id="text-org9558c45">
<p>
The built-in prime? procedure isn't fooled by the given Carmichael numbers in footnote 47:
</p>

<pre class="example" id="orgba07576">
(define (smallest-divisor n)
  (find-divisor n 2))
(define (find-divisor n test-divisor)
  (cond ((&gt; (square test-divisor) n) n)
        ((divides? test-divisor n) test-divisor)
        (else (find-divisor n (+ test-divisor 1)))))
(define (divides? a b)
  (= (remainder b a) 0))

(define (prime? n)
  (= n (smallest-divisor n)))

(define (expmod base exp m)
  (cond ((= exp 0) 1)
        ((even? exp)
         (remainder (square (expmod base (/ exp 2) m))
                    m))
        (else
         (remainder (* base (expmod base (- exp 1) m))
                    m))))
(define (fermat-test n)
  (define (try-it a)
    (= (expmod a n n) a))
  (try-it (+ 1 (random (- n 1)))))

; test built-in prime test
(prime? 561)
; test book prime test
(fermat-test 561)

1 ]=&gt; 
;Value: #f
1 ]=&gt; 
;Value: #t
</pre>
</div>
<div id="outline-container-org43e3d6c" class="outline-4">
<h4 id="org43e3d6c">Ex 1.22</h4>
<div class="outline-text-4" id="text-org43e3d6c">
<p>
Let's write search-for-primes. The modern x86 or ARM64 desktop/laptop can execute ~100m operations per second and the interpreter will be slower but still it's going to be at least tens of millions per second. There is no point testing the times unless you start at enormous inputs of 1 trillion or more. 
</p>

<pre class="example" id="orga72495e">
(define (timed-prime-test n)
  (start-prime-test n (runtime)))
(define (start-prime-test n start-time)
  (if (prime? n)
      (report-prime n (- (runtime) start-time))
      false))  
		    
(define (report-prime n elapsed-time)
  (newline)
  (display "Prime ")
  (display n)
  (display " took this long to find: ")
  (display elapsed-time))

(define (first-three-primes start max)
  (newline)
  (display "Here are the first 3 primes from ") (display start) (display " to ") (display max)
   
  (define (find-p n counter)
    (cond ((&gt; n max) (display "\n Exhausted Range"))
	  ((&gt; counter 2) (display "\n End of Primes"))
	  ((timed-prime-test n) (find-p (+ n 2) (+ 1 counter)))
	   (else (find-p (+ n 2) counter)))) ;; For Carmichael numbers 

  ;... omitted predicates here in the trampoline for even? then (+ 1 n)
  (find-p start 0))
    
(define (giga-prime-finder)
  ; 12 zeros
  (first-three-primes 1000000000000 10000000000000)
  ; 13 zeros
  (first-three-primes 10000000000000 100000000000000))

(giga-prime-finder)

1 ]=&gt;
Here are the first 3 primes from 1000000000000 to 10000000000000
Prime 1000000000039 took this long to find: 1.2100000000000009
Prime 1000000000061 took this long to find: 1.1999999999999993
Prime 1000000000063 took this long to find: 1.2100000000000009
 End of Primes
Here are the first 3 primes from 10000000000000 to 100000000000000
Prime 10000000000037 took this long to find: 3.7799999999999994
Prime 10000000000051 took this long to find: 3.789999999999999
Prime 10000000000099 took this long to find: 3.75
 End of Primes
</pre>

<p>
Adding a factor of 10 increases runtime by roughly 3x which is the sqrt of 10. 
</p>
</div>
</div>
<div id="outline-container-org715643f" class="outline-4">
<h4 id="org715643f">Ex 1.23</h4>
<div class="outline-text-4" id="text-org715643f">
<p>
After you discover that the repeated and needless testing of even numbers with an if predicate slows the process down try the following:
</p>

<pre class="example" id="orga0cfebc">
(define (bytwo? n)
  (divides? n 2))

; change defaults to 3
(define (smallest-divisor n)
  (find-divisor n 3))

; add this one-time check to your search-for-primes function
; assuming you are using a 'trampoline' and have a nested internal find function
 (if (bytwo? start)
      (find-p (+ 1 start) 0))
      (find-p start 0)))
</pre>

<p>
Testing the same trillion large input I get a runtime ratio on average of 1.21/.609 or ~2 the ratio we were looking for as it was the repeated if predicate slowing the runtime down. 
</p>
</div>
</div>
<div id="outline-container-orgfcd725f" class="outline-4">
<h4 id="orgfcd725f">Ex 1.24</h4>
<div class="outline-text-4" id="text-orgfcd725f">
<p>
Impossible to test on modern machines because CPUs do so much magic with optimizing constant ops since the 1980s no matter what large input you won't see an O(log n) process. In the book they claim the random sample of just 2 choices is better than a 3 out of 4 chance that n is prime so 1 - (1/2)<sup>2</sup> is 0.75 and in Sussman's MIT course <a href="https://groups.csail.mit.edu/mac/users/gjs/6.945/assignments.html">Assignment 0</a> Diffie-Helman is the same problem where he recommends minimum 20 random values be tested so 1 - (1/2)<sup>20</sup> or 0.9999.. but even with 50 tests the runtime is still constant on my machine or O(1).
</p>
</div>
</div>
<div id="outline-container-org3ae5ce7" class="outline-4">
<h4 id="org3ae5ce7">Misc exercises</h4>
<div class="outline-text-4" id="text-org3ae5ce7">
<p>
Ex 1.25 The 'A lisp hacker' solution the call to fast-expt will keep on going squaring gigantic numbers until it returns the square whereas expmod every loop calls remainder with m on delayed computations so when they get to the delayed squaring ops they are small. If you hand evaluate expmod for 3<sup>7</sup> modulo 7 I think the biggest square in all the returns was 36. 
</p>

<p>
Ex 1.26 A 'loose reasoner' the hint is Eva Lu Ator because scheme uses applicative-order evaluation so (square (params)) the params are evaluated to a value only once then square is applied where (* (params) (params)) is evaluated twice before multiplication is applied to the values so successive doubling of work everytime that cond branch is used. 
</p>

<p>
The last exercise 1.28 is explained <a href="https://stackoverflow.com/questions/3733384/confused-on-miller-rabin">here</a> where 'nontrivial' means something that isn't 1 since 1<sup>2</sup> has a trivial square root of 1 but any odd number squared mod 8 has a nontrivial square root of 1 for example 3<sup>2</sup> mod 8 or 9 mod 8 is 1 so now 3 is a nontrivial square root of 1 mod 8. The exercise is actually trivial even if the square root is nontrivial all you have to do is drop a check in the squaring branch of expmod "n = not 1 or n-1 and n<sup>2</sup> = 1 mod n" to reveal if it's a nontrivial square root and if so return 0 wiping out all the delayed multiplication and remainders of expmod so when the result gets back to fermat-test it compares a to 0. 
</p>

<p>
If you enjoy the strange world of number theory we'll be doing more of it when we cover Sussman's new book and Richard Borcherds a Fields medalist has a <a href="https://www.youtube.com/playlist?list=PL8yHsr3EFj53L8sMbzIhhXSAOpuZ1Fov8">playlist</a> on his YouTube channel teaching an introduction if interested. 
</p>
</div>
</div>
</div>
<div id="outline-container-org6d9f7f4" class="outline-3">
<h3 id="org6d9f7f4">SICP 1.3.1</h3>
<div class="outline-text-3" id="text-org6d9f7f4">
<p>
The integrals in this chapter aren't used only the numerical approximations which we are given full formulas for are so if you've never taken calculus it won't matter.
</p>
</div>
<div id="outline-container-orgff09fa6" class="outline-4">
<h4 id="orgff09fa6">Ex 1.29</h4>
<div class="outline-text-4" id="text-orgff09fa6">
<p>
The Simpson's rule is explained <a href="https://www.intmath.com/integration/6-simpsons-rule.php">here</a> (click on show answer) 
</p>

<p>
We're asked to define a procedure that takes arguments f, a, b, n where f is a function to integrate, a and b are the integral ranges and n is a precision number.
</p>

<pre class="example" id="org0fafdc6">
(define (sum term a next b)
  (if (&gt; a b)
      0
      (+ (* (term a))
         (sum term (next a) next b))))

(define (srule f a b n)
  (define (parity x) (+ x 2))
  (define delta-x (/ (- b a) n)) 
  (define (y k) (f (+ a (* k delta-x))))
  (* (/ delta-x 3)
     (+ (* (sum y 1 parity (- n 1)) 4)
        (* (sum y 2 parity (- n 1)) 2)
	   (y 0)
	   (y n))))
	   
; test functions y = 1/x+1 and y = x^2
(define (fun x) (/ 1.0 (+ x 1)))
(define (pow x) (* x x))

; this should equal ~0.2876831 
(srule fun 2 3 4)
; this should equal 215/3
(srule pow 1 6 4)
</pre>

<p>
Exercise 1.30 to 1.33 are standard programming introducing the concept of fold/reduce (accumulate) and filter which will be used later on lists and streams. 
</p>
</div>
</div>
<div id="outline-container-orge4a0353" class="outline-4">
<h4 id="orge4a0353">Ex. 1.34</h4>
<div class="outline-text-4" id="text-orge4a0353">
<pre class="example" id="orga0d98bb">
(define (f g) (g 2))
</pre>

<p>
If f is applied to itself, then it becomes the g in (g 2) which then will be given 2 as the parameter for g and pass that to it's body trying to eval (2 2) an error. 
</p>

<p>
TODO
</p>
</div>
</div>
</div>
</div>
<div id="outline-container-orgc3cec6a" class="outline-2">
<h2 id="orgc3cec6a">SDF 0</h2>
<div class="outline-text-2" id="text-orgc3cec6a">
<p>
Now that we've finished Chapter 1 we can do the first pset from Sussman's 2024 <a href="https://groups.csail.mit.edu/mac/users/gjs/6.945/index.html">course</a> <i>Adventures in Advanced Symbolic Programming</i> and latest book <i>Software Design for Flexibiliy</i> (SDF). Let's try <a href="https://groups.csail.mit.edu/mac/users/gjs/6.945/assignments.html">Assignment 0</a> Diffie-Helman it's only prereq is SICP Chapter 1. TODO
</p>

<p>
.. cont
</p>

<hr />
<p>
<a href="https://learnaifromscratch.github.io/">Home</a>
</p>
</div>
</div>
</div>
</body>
</html>
